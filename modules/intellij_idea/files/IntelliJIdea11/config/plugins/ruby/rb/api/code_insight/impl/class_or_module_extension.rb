#
# Copyright 2000-2009 JetBrains s.r.o.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

include Java

require File.expand_path(File.dirname(__FILE__) + '/internal_ruby_code_insight_helper')
require File.expand_path(File.dirname(__FILE__) + '/completion_helper')

class JetBrains::RubyMine::API::ClassOrModuleExtension
  import org.jetbrains.plugins.ruby.gem.GemDependency unless defined? GemDependency
  include JetBrains::RubyMine::Internal_RubyCodeInsightHelper
  include JetBrains::RubyMine::API::CompletionHelper::InsertHandlers

  def initialize class_or_module
    @class_or_module = class_or_module
  end

  # Associates method with return type
  # * methods_and_types - Hash. Each key is method name and value is return type provider.
  # Provider may be full qualified name of birth class or type computable object
  # E.g.
  #  return_type "action_name" => "String"
  #  return_type "action_name" => SomeTypeComputable.new
  def set_return_type methods_and_types
    methods_and_types.each_pair do |method_name, type_provider|
      associate_method_with_type method_fqn(method_name), type_provider
    end
  end

  # Associates method with insert handler
  # Insert handler will be invoked after selecting item in autocompletion popup
  # * handlerDescr - String or insert handler factory. See JetBrains::RubyMine::API::CompletionHelper::InsertHandlers.
  # * methods - String or Array of method names
  # E.g.
  #  set_insert_handler "foo"
  #  set_insert_handler "foo", "boo"
  #  return_type "action_name" => SomeTypeComputable.new
  def set_insert_handler(handler_descr, *methods)
    handler = if (String === handler_descr)
      simple_after_method_insert_handler(handler_descr)
    else
      handler_descr
    end
    methods.each do |method_name|
      associate_method_with_insert_handler method_fqn(method_name), handler
    end
  end

  # Associates method's block variable with return type
  # * methods_and_types - Hash. Each key is method name and value is return type provider.
  # Provider may be full qualified name of birth class or type computable object ((RSymbolBasedTypeComputable)
  # E.g.
  #  block_variable_type "times" => "Fixnum"
  #  block_variable_type "each" => SomeTypeComputable.new
  def set_block_variable_type methods_and_types
    methods_and_types.each_pair do |method_name, type_provider|
      associate_yield_variable_with_type method_fqn(method_name), type_provider
    end
  end

  # Associates current target (specified in "describe") with dynamic type.
  # Such type accept any call and return dynamic type. E.g. Builder::XmlMarkup
  # options:
  #   :recursive  - if given members will have same return type, otherwise empty type
  #   :type - type provider  - if given type will be used as return type
  def set_dynamic_class_type(options = {})
    associate_class_with_dynamic_type @class_or_module, options
  end

  # Registers dynamic methods in RubyMine. It is useful for describing methods which doesn't exist
  # in static but will be dynamically generated by ruby.
  #
  # * options:
  #   If value is String or Array it will be considered as Hash = {:methods => value}
  #   - :methods - method name(s) to register
  #   - :context - register methods as instance(:instance) or class methods(:class). If not specified default value will be :instance.
  #   - :name - if specified will be added to describe target
  #   - :method_to_resolve - if method descriptor specified will be used for resolving. It can be MethodDescriptor object,
  # String or Hash with keys
  #         :name  - method fully qualified name
  #         :context - instance(:instance)/class(:class) context
  #   - :class_to_resolve - String value. Fully qualified name of class that should be considered as method declaration
  #   - :module_to_resolve - String value. Fully qualified name of module that should be considered as method declaration
  # if method_to_resolve is String value it will be converted to Hash {:name => method_to_resolve}
  def set_dynamic_methods(options)
    # normalize options
    case options
      when Array, String
        options = {:methods => options}
    end
    # method to resolve
    if resolve_to_method_options = options[:method_to_resolve]
      case resolve_to_method_options
        when Hash, String
          resolve_to_method_options = {:name => resolve_to_method_options} if (resolve_to_method_options.is_a?(String))
          resolve_target = target_descriptor(resolve_to_method_options[:name],
                                             extract_type_context_from(resolve_to_method_options))
        else
          resolve_target = resolve_to_method_options
      end
    elsif class_name = options[:class_to_resolve]
      resolve_target = target_descriptor(class_name, :class)
    elsif module_name = options[:module_to_resolve]
      resolve_target = target_descriptor(module_name, :module)
    else
      resolve_target = nil
    end

    # required gem
    if required_gem_options = options[:gem]
      name_and_version = required_gem_options.split(/ /, 2)
      required_gem = GemDependency.create(name_and_version[0], name_and_version[1])
    end

    # type
    type = extract_type_context_from(options)

    # register methods
    register_dynamic_methods "#{@class_or_module}#{options[:name] ? "::#{options[:name]}" : ''}",
                             type,
                             options[:methods].to_a,
                             resolve_target,
                             required_gem
  end

  private
  def extract_type_context_from(options)
    "#{(options[:context] || :instance).to_s}_method".to_sym
  end

  def method_fqn(method_name)
    "#{@class_or_module}.#{method_name}"
  end
end
